We intend to create a unique, combinational project. The first, and main, component will be a multiplayer tank-style game in the terminal. It will be played 1-on-1 in a tournament style format and ideally people who are eliminated will be able to watch the games of those remaining (or we’d just have a consolation bracket). The largest issue we foresee would be dealing with synchronization across devices (ensuring that both players see the same screen), but that could be worked around by slowing down the pace of play. This will at least use threads, scheduling, and networking. Scheduling clearly comes into play in relation to updating the game, screen, and listening for input. Networking is how the game is going to allow multiple players, and we would have a thread listening for incoming messages while the other runs the game.
The second component will be in the background. When players join the network to play the tanks game in class, they'll be prompted to create a username and password. While the tournament is being played, each user's computer will be using the GPU to crack passwords in the background. Given the potential GPU speedup, the increased number of computers, and the theoretically decreased percentage of the search space required before all passwords are found, we're optimistic about the relaxing of the constraints on passwords that we'll be able to allow and still crack within the allotted time. This would obviously use GPU Parallelism, synchronization, and networking. The GPU for password cracking. Synchronization is especially necessary since we’ll have a much smaller number of passwords to check this time, so we can get significant time benefits by ending once we’ve found the last one. Finally, Networking is essential to utilize the full computational potential of the cluster of computers that’ll be connected to play the game.
We will implement this project by using the worm-drawing code as a building-off point for our own implementation of a tank type movement. Since it’s essentially just modifying values in an array and then telling the system what to translate those values too, it should be relatively approachable to implement the game interface in the terminal. The difficulty with making an interesting game of this type in the terminal is the fact that aiming is limits to axis or maybe diagonals. To deal with this, we’re going to have weapons and abilities that act in cones or rings instead of straight lines. In terms of networking, each machine will connect to the main host (the computer we’re on when we’re presenting) and then that host will pair them off for each round. From there, each player will connect to their pair and play the game p2p. The system will have to listen to a message from their partner before updating the screen image. This is the part where we might encounter issues with delay and inconsistency. The system can’t wait for each person to make a move or the pace-of-play will crawl to a halt, but it also can’t just update the screen whenever someone inputs something without waiting for their partner to send a message because then they’ll get out of sync. Plus, we can’t be sure that each message arrives, which is commonly known as the General’s Paradox. Worst case scenario, we can make one player in each pair the “server” and they’d have a big advantage, but we could always just artificially add lag to their system.
To implement the password cracking, we will have to port our current password cracking algorithm to the GPU, which will not only involve setting up the password to be run in batches, but also writing a MD5 function that can be run on the __device__ since the current MD5 library we’re using is for CPUs. In terms of networking, we’ll simply send the offset to each participant depending on the number of computers connected. The offset will just be the total number of passwords in the search space divided by the number of nodes. That way each node only has to deal with a subset of the search space and doesn’t have to worry about overlap. The main issue that might come up is the implementation of MD5 being harder than imagined. Additionally, if we can’t achieve the speedup we’re expecting, we could still crack passwords and just add some more constraints on characters or size. Ultimately, since this is a sort of bonus surprise and we fulfill all of the project requirements without it, we could just scrap it if it proves unfeasible.
